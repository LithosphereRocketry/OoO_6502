; Based on http://www.6502.org/users/obelisk/6502/reference.html

@0x69 ; ADC immediate
    ld tmp0, {pch, pcl}, zero ; load 1 byte immediate (PC+1)
    add {flag, acc}, {flag, acc}, tmp0 ; perform operation
    term {pch, pcl}, 1 ; terminate, skipping over 1-byte immediate

@0x65 ; ADC zero page
    ld tmp0, {pch, pcl}, zero ; load 1 byte immediate (PC+1)
    ld tmp0, {zero, tmp0}, zero ; load value from zero page
    add {flag, acc}, {flag, acc}, tmp0 ; perform operation
    term {pch, pcl}, 1 ; terminate, skipping over 1-byte immediate

@0x75 ; ADC zero page, x
    ld tmp0, {pch, pcl}, zero ; load 1 byte immediate (PC+1)
    ldc tmp0, {zero, tmp0}, x ; load value from zero page
    add {flag, acc}, {flag, acc}, tmp0 ; perform operation
    term {pch, pcl}, 1 ; terminate, skipping over 1-byte immediate

@0x6D ; ADC absolute
    ld tmp0, {pch, pcl}, zero ; load address lower byte
    ld tmp1, {pch, pcl}, one ; load address upper byte
    ld tmp0, {tmp1, tmp0}, zero ; fetch indirected value
    add {flag, acc}, {flag, acc}, tmp0 ; perform operation
    term {pch, pcl}, 2 ; terminate, skipping over 2-byte immediate

@0xF0 ; BEQ
    ld tmp0, {pch, pcl}, zero ; load 1 byte immediate (PC+1)
    cterm {pch, pcl}, tmp0, flag @ 1 ; branch conditionally on carry bit
    term {pch, pcl}, 1 ; if branch not taken, fall through

@0x18 ; CLC
    bit flag, flag @ !0
    term {pch, pcl}, 0 ; terminate, no immediate

@0xC9 ; CMP immediate
    ld tmp0, {pch, pcl}, zero ; load 1 byte immediate (PC+1)
    cmp flag, {flag, acc}, tmp0 ; perform operation
    term {pch, pcl}, 1 ; terminate, skipping over 1-byte immediate

@0x88 ; DEY
    sub {zero, y}, {one, y}, one ; perform subtraction
    mov {flag, zero}, {flag, y} ; looks like a noop, but sets carry flags
    term {pch, pcl}, 0 ; terminate, no immediate


@0x4C ; JMP absolute
    ld tmp0, {pch, pcl}, zero ; load address lower byte
    ld tmp1, {pch, pcl}, one ; load address upper byte
    term {tmp1, tmp0}, 0 ; perform jump

@0x20 ; JSR
    ; this one is a little awkward: we need to push PC+2 to the stack, then
    ; load from PC+1 and PC+2 and jump
    add {tmp1, tmp0}, {zero, pcl}, one ; increment PC lower half
    add {zero, tmp1}, {tmp1, pch}, zero ; propagate carry to upper half
    st tmp1, {one, sp}, zero ; put value on stack (6502 SP points to first free)
    sub {zero, sp}, {one, sp}, one ; move to next free
    st tmp0, {one, sp}, zero ; put value on stack (6502 SP points to first free)
    sub {zero, sp}, {one, sp}, one ; move to next free
    ld tmp0, {pch, pcl}, zero ; lower byte of destination
    ld tmp1, {pch, pcl}, one ; upper byte of destination
    term {tmp1, tmp0}, 0 ; jump to destination

@0xA9 ; LDA immediate
    ld acc, {pch, pcl}, zero ; load 1 byte immediate (PC+1)
    mov {flag, zero}, {flag, acc} ; looks like a noop, but sets carry flags
    ; (note we move to zero here and not acc to avoid creating false dependency)
    term {pch, pcl}, 1 ; terminate, skipping over 1-byte immediate

@0xA5 ; LDA zero-page
    ld tmp0, {pch, pcl}, zero ; load 1 byte immediate (PC+1)
    mov {flag, zero}, {flag, acc} ; looks like a noop, but sets carry flags
    ld acc, {zero, tmp0}, zero ; load value
    term {pch, pcl}, 1 ; terminate, skipping over 1-byte immediate

@0xA2 ; LDX immediate
    ld x, {pch, pcl}, zero ; load 1 byte immediate (PC+1)
    mov {flag, zero}, {flag, x} ; looks like a noop, but sets carry flags
    ; (note we move to zero here and not acc to avoid creating false dependency)
    term {pch, pcl}, 1 ; terminate, skipping over 1-byte immediate

@0x48 ; PHA
    st acc, {one, sp}, zero ; SP points to first free byte
    sub {zero, sp}, {one, sp}, one ; point to next free
    term {pch, pcl}, 0 ; terminate, no immediate

@0x68 ; PLA
    add {zero, sp}, {zero, sp}, one
    ld acc, {one, sp}, zero
    term {pch, pcl}, 0

@0x60 ; RTS
    add {zero, sp}, {zero, sp}, one
    ld tmp0, {one, sp}, zero
    add {zero, sp}, {zero, sp}, one
    ld tmp1, {one, sp}, zero
    term {tmp1, tmp0}, 1 ; JSR leaves return-1 on the stack so add a +1 here

@0x85 ; STA zero-page
    ld tmp0, {pch, pcl}, zero ; load 1 byte immediate (PC+1)
    st acc, {zero, tmp0}, zero ; store value
    term {pch, pcl}, 1 ; terminate, skipping over 1-byte immediate

@0x8D ; STA absolute
    ld tmp0, {pch, pcl}, zero ; load address lower byte
    ld tmp1, {pch, pcl}, one ; load address upper byte
    st acc, {tmp1, tmp0}, zero ; store value
    term {pch, pcl}, 2 ; terminate, skipping over 2-byte immediate

@0xA8 ; TAY
    mov {flag, y}, {flag, acc} ; Move setting flags
    term {pch, pcl}, 0 ; terminate, no immediate

@0x9A ; TXS
    mov {zero, sp}, {zero, x} ; Move setting no flags
    term {pch, pcl}, 0 ; terminate, no immediate

@0x98 ; TYA
    mov {flag, acc}, {flag, y} ; Move setting no flags
    term {pch, pcl}, 0 ; terminate, no immediate


